# 技术要点文档

## 1. 架构设计

### 1.1 整体架构
- **Web 框架**：Flask（轻量级 WSGI 应用）
- **WSGI 服务器**：Gunicorn（生产环境）
- **架构模式**：事件驱动 + 异步处理
- **部署方式**：内网服务器部署，支持私有化飞书环境

### 1.2 核心模块
```
feishu-bitable-receiver/
├── app/
│   ├── main.py                    # Flask 应用主入口
│   ├── cloud_doc_download.py     # 云文档下载模块
│   ├── pull_bitable.py           # 多维表格拉取模块（桥接）
│   ├── sankey_service_with_polling.py  # 桑基图生成服务
│   └── security.py               # 签名校验模块
├── pull_bitable.py               # 多维表格数据拉取核心逻辑
├── wsgi.py                       # Gunicorn WSGI 入口
└── requirements.txt              # 依赖管理
```

## 2. 核心技术栈

### 2.1 后端框架
- **Flask 3.0.3**：轻量级 Web 框架，处理 HTTP 请求
- **Gunicorn 21.2.0**：生产级 WSGI 服务器，支持多进程/多线程

### 2.2 数据处理
- **Pandas ≥1.5.0**：数据处理和 Excel 转换
- **OpenPyXL 3.1.5**：Excel 文件读写
- **PyECharts ≥2.0.0**：桑基图可视化生成

### 2.3 网络请求
- **Requests 2.32.3**：HTTP 客户端，调用飞书 API

### 2.4 配置管理
- **python-dotenv 1.0.1**：环境变量管理，从 `.env` 文件加载配置

## 3. 关键功能实现

### 3.1 飞书事件订阅处理

#### 3.1.1 URL 验证（Challenge）
```python
# 飞书首次配置回调 URL 时会发送 challenge 请求
challenge = body.get("challenge")
if challenge:
    return jsonify({"challenge": challenge})
```
- **要点**：必须在 1 秒内返回 challenge 值
- **实现**：直接解析 JSON body，快速响应

#### 3.1.2 签名校验
```python
# HMAC-SHA256 签名验证
ts = request.headers.get("x-lark-request-timestamp")
nonce = request.headers.get("x-lark-request-nonce")
sig = request.headers.get("x-lark-signature")
ok = verify_signature(raw, ts, nonce, sig, ENCRYPT_KEY)
```
- **算法**：`HMAC-SHA256(EncryptKey, timestamp + nonce + rawBody)`
- **安全性**：防止请求被篡改，确保来源可信

#### 3.1.3 事件路由
- **消息接收事件**：`im.message.receive_v1`
- **消息已读事件**：`im.message.message_read_v1`（跳过处理）
- **其他事件**：直接返回 200，不做业务处理

### 3.2 消息幂等性保证

#### 3.2.1 实现机制
```python
# 全局消息 ID 缓存
PROCESSED_MESSAGE_IDS = set()

# 在处理开始前立即记录 message_id
if message_id:
    PROCESSED_MESSAGE_IDS.add(message_id)
```
- **策略**：基于 `message_id` 的去重机制
- **时机**：在处理开始前立即记录，防止飞书重试导致重复处理
- **存储**：内存 Set 结构，轻量高效

#### 3.2.2 处理流程
1. 提取 `message_id`
2. 检查是否已处理 → 已处理则直接返回 200
3. 立即记录 `message_id` 到缓存
4. 执行业务逻辑
5. 确保所有路径都返回 200（避免飞书重试）

### 3.3 多维表格（Bitable）数据拉取

#### 3.3.1 链接解析
- **完整链接**：`/base/{app_token}?table={table_id}&view={view_id}`
- **仅 Base 链接**：`/base/{app_token}`（自动选择首表首视图）
- **正则匹配**：使用 `re.search()` 提取 token、table_id、view_id

#### 3.3.2 数据拉取流程
1. **获取 Tenant Access Token**
   - 接口：`POST /open-apis/auth/v3/tenant_access_token/internal`
   - 缓存机制：Token 有效期 2 小时，避免频繁请求

2. **获取表格元数据**
   - 接口：`GET /open-apis/bitable/v1/apps/{app_token}`
   - 获取 Base 名称（用于文件命名）

3. **拉取记录数据**
   - 接口：`GET /open-apis/bitable/v1/apps/{app_token}/tables/{table_id}/records`
   - 支持视图筛选：`view_id` 参数
   - 保持列顺序：按视图中的列顺序导出

4. **数据转换**
   - 字段类型处理：文本、数字、日期、多选、人员等
   - 列表/对象转换：转换为可读字符串
   - DataFrame 构建：使用 Pandas 构建结构化数据

5. **Excel 导出**
   - 文件命名：`{Base名称}-{发送者ID}-{北京时间}.xlsx`
   - 格式：无表头，保持原始数据格式

### 3.4 云文档（Sheets/Docs/File）下载

#### 3.4.1 链接类型识别
```python
is_sheets = "/sheets/" in doc_link
is_cloud_doc = "/file/" in doc_link or "/docs/" in doc_link
```
- **Sheets**：使用读取接口（v2/metainfo + v2/values）
- **其他云文档**：使用下载接口（drive/v1/files/{token}/download）

#### 3.4.2 Sheets 数据读取（核心实现）

**步骤 1：获取表格元数据**
```python
# 使用 v2/metainfo 接口
GET /open-apis/sheets/v2/spreadsheets/{file_token}/metainfo
```
- **返回数据**：
  - `data.properties.title`：表格名称（用于文件命名）
  - `data.sheets[]`：Sheet 列表
  - `data.sheets[0].sheetId`：第一个 Sheet 的 ID

**步骤 2：读取 Sheet 数据**
```python
# 使用 v2/values 接口
GET /open-apis/sheets/v2/spreadsheets/{file_token}/values/{sheet_id}
```
- **返回数据**：
  - `data.valueRange.values`：二维数组，表示单元格数据

**步骤 3：转换为 Excel**
```python
df = pd.DataFrame(values)
df.to_excel(output_path, index=False, header=False, engine='openpyxl')
```

#### 3.4.3 文件命名策略
- **Sheets**：使用实际文件名（从 metainfo 获取）
- **其他云文档**：使用默认名称"云文档"
- **格式**：`{文件名}-{sender_id}-{timestamp}.xlsx`
- **特殊字符处理**：使用正则替换 `[<>:"/\\|?*]` 为下划线

### 3.5 桑基图生成

#### 3.5.1 服务集成
- **内置服务**：`app/sankey_service_with_polling.py`
- **单次生成模式**：不启动轮询，直接调用生成方法
- **服务实例化**：每次请求创建新实例，避免状态污染

#### 3.5.2 生成流程
1. **预算文件转边表**
   ```python
   edges_file_path = sankey_service.convert_budget_to_edges(excel_file_path)
   ```
   - 解析 Excel 结构：时间列、项目列、描述列、总预算列
   - 构建边表：源节点 → 目标节点 → 数值
   - 文件命名：`{预算文件名}_edges.xlsx`

2. **生成桑基图 HTML**
   ```python
   sankey_service.generate_sankey_chart(
       edges_path=edges_file_path,
       output_html_path=html_output_path,
       budget_path=excel_file_path  # 用于加载节点描述
   )
   ```
   - 使用 PyECharts 生成交互式图表
   - 节点描述：从预算文件加载，支持点击查看
   - HTML 注入：JavaScript 事件绑定，实现节点点击弹窗

3. **HTML 文件命名**
   - 格式：`{预算文件名}_桑基图.html`
   - 路径：`SANKEY_OUTPUT_DIR`

4. **临时文件清理**
   - 边表文件：生成后立即删除，避免磁盘占用

#### 3.5.3 HTML 节点交互实现
- **技术**：PyECharts + JavaScript DOM 操作
- **实现**：检测 HTML 嵌套，正确注入事件监听器
- **功能**：点击节点显示项目描述弹窗

### 3.6 静态文件服务

#### 3.6.1 HTML 文件访问
```python
@app.route("/sankey/<path:filename>")
def serve_sankey_html(filename):
    # URL 解码文件名
    decoded_filename = urllib.parse.unquote(filename)
    # 路径遍历防护
    if '..' in decoded_filename or decoded_filename.startswith('/'):
        return "Invalid filename", 400
    # 返回文件
    return send_from_directory(SANKEY_OUTPUT_DIR, decoded_filename)
```
- **URL 编码**：支持中文文件名（URL 编码/解码）
- **安全防护**：防止路径遍历攻击
- **访问方式**：`http://IP:PORT/sankey/{文件名}`

#### 3.6.2 链接生成
```python
def get_sankey_html_url(filename: str) -> str:
    encoded_filename = urllib.parse.quote(filename)
    base_url = f"http://{HOST}:{PORT}/sankey"
    return f"{base_url}/{encoded_filename}"
```
- **动态 IP**：从环境变量 `HOST` 读取服务器 IP
- **端口配置**：从环境变量 `PORT` 读取
- **URL 编码**：确保特殊字符正确传输

## 4. API 集成

### 4.1 飞书 API 调用

#### 4.1.1 Tenant Access Token 获取
- **接口**：`POST /open-apis/auth/v3/tenant_access_token/internal`
- **认证方式**：App ID + App Secret
- **缓存策略**：内存缓存，2 小时有效期
- **错误处理**：Token 获取失败时抛出异常

#### 4.1.2 消息回复
- **接口**：`POST /open-apis/im/v1/messages/{message_id}/reply`
- **认证**：Bearer Token（Tenant Access Token）
- **消息格式**：JSON，支持文本消息
- **错误处理**：记录日志，不阻塞主流程

#### 4.1.3 多维表格 API
- **获取 Base 信息**：`GET /open-apis/bitable/v1/apps/{app_token}`
- **获取表列表**：`GET /open-apis/bitable/v1/apps/{app_token}/tables`
- **获取记录**：`GET /open-apis/bitable/v1/apps/{app_token}/tables/{table_id}/records`
- **视图筛选**：通过 `view_id` 参数筛选

#### 4.1.4 Sheets API
- **获取元数据**：`GET /open-apis/sheets/v2/spreadsheets/{token}/metainfo`
- **读取数据**：`GET /open-apis/sheets/v2/spreadsheets/{token}/values/{sheet_id}`
- **权限要求**：`drive:drive:readonly`

#### 4.1.5 Drive API
- **下载文件**：`GET /open-apis/drive/v1/files/{token}/download`
- **权限要求**：`drive:drive:readonly`

### 4.2 API 错误处理

#### 4.2.1 错误分类
- **权限错误**（403）：`permission_denied`
- **文件不存在**（404）：`file_not_found`
- **API 错误**：解析 `code` 和 `msg` 字段
- **网络错误**：捕获 `requests.exceptions.RequestException`

#### 4.2.2 错误消息映射
```python
if error == "permission_denied" or error == "file_not_found":
    reply_message(message_id, "文档访问失败，请检查：\n\n1. 链接是否正确\n\n2. 应用是否有访问权限\n\n3. 文件是否已分享给应用")
elif error == "format_error":
    reply_message(message_id, "Excel 文件格式不符合要求，请确保文件包含：\n\n1. 第一列为时间列\n\n2. 后续列为成对的项目列和描述列\n\n3. 最后一列为总预算\n\n4. 数据行完整")
else:
    reply_message(message_id, "桑基图生成失败，请联系服务管理员")
```

## 5. 数据处理

### 5.1 Excel 文件处理

#### 5.1.1 文件验证
- **文件头检查**：验证是否为有效的 Excel 文件（`PK\x03\x04`）
- **文件大小检查**：确保文件非空
- **格式验证**：检查列结构是否符合桑基图要求

#### 5.1.2 数据转换
- **多维表格**：字段类型转换（文本、数字、日期、多选、人员等）
- **Sheets**：直接使用二维数组，保持原始格式
- **DataFrame 构建**：使用 Pandas 构建结构化数据

### 5.2 文件命名策略

#### 5.2.1 命名格式
- **多维表格**：`{Base名称}-{sender_id}-{timestamp}.xlsx`
- **Sheets**：`{表格名称}-{sender_id}-{timestamp}.xlsx`
- **其他云文档**：`云文档-{sender_id}-{timestamp}.xlsx`

#### 5.2.2 特殊字符处理
```python
safe_name = re.sub(r'[<>:"/\\|?*]', '_', base_name)
```
- **替换规则**：将文件系统不支持的字符替换为下划线
- **时间格式**：`YYYYMMDD_HHMMSS`（北京时间 UTC+8）

## 6. 错误处理与日志

### 6.1 异常处理策略

#### 6.1.1 分层异常处理
- **网络层**：捕获 `requests.exceptions.RequestException`
- **数据层**：捕获 `KeyError`、`IndexError`（格式错误）
- **文件层**：捕获 `IOError`、`OSError`
- **通用异常**：捕获 `Exception`，记录完整堆栈

#### 6.1.2 错误响应
- **所有错误路径**：确保返回 200 状态码（避免飞书重试）
- **用户友好消息**：根据错误类型返回具体提示
- **日志记录**：记录详细错误信息，便于排查

### 6.2 日志系统

#### 6.2.1 日志配置
- **文件日志**：`logs/access.log`（访问日志）、`logs/error.log`（错误日志）
- **消息日志**：`logs/messages.log`（消息事件记录）
- **桑基图日志**：`logs/sankey_service.log`（桑基图生成日志）

#### 6.2.2 日志级别
- **INFO**：正常业务流程、API 调用
- **ERROR**：错误信息、异常堆栈
- **DEBUG**：调试信息（请求头、请求体等）

#### 6.2.3 日志格式
```python
formatter = logging.Formatter('%(asctime)s %(levelname)s in %(module)s: %(message)s')
```

## 7. 安全机制

### 7.1 签名校验
- **算法**：HMAC-SHA256
- **密钥**：从环境变量 `ENCRYPT_KEY` 读取
- **实现**：`app/security.py` 中的 `verify_signature()` 函数

### 7.2 路径遍历防护
```python
if '..' in decoded_filename or decoded_filename.startswith('/'):
    return "Invalid filename", 400
```
- **防护措施**：禁止 `..` 和绝对路径
- **白名单机制**：只允许访问 `SANKEY_OUTPUT_DIR` 目录

### 7.3 敏感信息保护
- **环境变量**：`.env` 文件不提交到 Git
- **配置隔离**：生产环境配置与代码分离
- **日志脱敏**：避免在日志中输出敏感信息

## 8. 部署方案

### 8.1 生产环境部署

#### 8.1.1 WSGI 服务器配置
```bash
gunicorn -w 3 --threads 2 --timeout 120 -b 0.0.0.0:3000 \
  --access-logfile ./logs/access.log \
  --error-logfile ./logs/error.log \
  --log-level info --capture-output \
  wsgi:app
```
- **工作进程**：3 个进程（`-w 3`）
- **线程数**：每个进程 2 个线程（`--threads 2`）
- **超时时间**：120 秒（`--timeout 120`）
- **日志**：访问日志和错误日志分离

#### 8.1.2 目录结构
```
/home/cnooc/python_app/feishu-bitable-receiver/
├── app/                    # 应用代码
├── logs/                   # 日志目录
├── .env                    # 配置文件（不提交 Git）
└── wsgi.py                 # WSGI 入口

/home/cnooc/file/
├── excel/                  # Excel 输出目录
└── sankey/                 # 桑基图 HTML 输出目录
```

### 8.2 配置管理

#### 8.2.1 环境变量
- **加载方式**：使用 `python-dotenv` 从 `.env` 文件加载
- **验证机制**：启动时检查必填配置项
- **类型转换**：`_get_bool()`、`_get_int()` 辅助函数

#### 8.2.2 配置项分类
- **飞书凭证**：APP_ID、APP_SECRET、OPEN_BASE
- **服务配置**：PORT、HOST
- **文件导出**：OUTPUT_DIR、EXPORT_XLSX
- **日志配置**：MESSAGES_LOG_PATH
- **桑基图配置**：SANKEY_OUTPUT_DIR、SANKEY_WATCH_DIR

## 9. 性能优化

### 9.1 Token 缓存
- **缓存策略**：内存缓存 Tenant Access Token
- **有效期**：2 小时（飞书 Token 有效期）
- **刷新机制**：过期后自动重新获取

### 9.2 异步处理
- **响应策略**：立即返回 200，后台处理业务逻辑
- **避免阻塞**：耗时操作（文件下载、桑基图生成）不阻塞 HTTP 响应

### 9.3 文件清理
- **临时文件**：边表文件生成后立即删除
- **磁盘管理**：避免临时文件堆积

## 10. 扩展性设计

### 10.1 模块化设计
- **独立模块**：`cloud_doc_download.py`、`pull_bitable.py` 可独立使用
- **接口统一**：统一的返回格式 `(bool, Optional[str], Optional[str])`
- **易于测试**：模块可单独测试

### 10.2 配置驱动
- **环境变量**：所有配置通过环境变量管理
- **灵活部署**：不同环境只需修改 `.env` 文件
- **无需改代码**：配置变更无需重新编译

### 10.3 错误处理扩展
- **错误类型**：统一的错误类型定义
- **消息映射**：错误类型到用户消息的映射
- **易于扩展**：新增错误类型只需添加映射

## 11. 关键技术难点

### 11.1 飞书事件重试机制
- **问题**：飞书在未收到 200 响应时会重试
- **解决**：所有路径都返回 200，幂等性保证只处理一次

### 11.2 Sheets API 兼容性
- **问题**：v3 接口不返回 sheets 列表
- **解决**：使用 v2/metainfo 接口获取 sheet_id

### 11.3 HTML 节点交互
- **问题**：PyECharts 生成的 HTML 嵌套导致事件绑定失败
- **解决**：检测 HTML 结构，正确注入 JavaScript 事件监听器

### 11.4 文件名特殊字符
- **问题**：文件名包含特殊字符导致文件系统错误
- **解决**：正则替换不支持的字符为下划线

### 11.5 时区处理
- **问题**：服务器时区与北京时间不一致
- **解决**：使用 `timezone(timedelta(hours=8))` 明确指定 UTC+8

## 12. 测试与验证

### 12.1 健康检查
```python
@app.route("/healthz")
def healthz():
    return jsonify({"status": "ok"})
```
- **用途**：服务可用性检查
- **部署验证**：部署后立即验证服务是否正常

### 12.2 消息日志
- **记录内容**：事件类型、消息 ID、发送者信息、消息内容
- **格式**：TSV（制表符分隔），便于分析
- **用途**：问题排查、数据分析

## 13. 最佳实践

### 13.1 代码规范
- **类型提示**：使用 `typing` 模块提供类型提示
- **文档字符串**：所有函数都有详细的 docstring
- **错误处理**：明确的异常类型和处理策略

### 13.2 日志实践
- **结构化日志**：统一的日志格式
- **日志级别**：合理使用 INFO、ERROR、DEBUG
- **敏感信息**：避免在日志中输出敏感信息

### 13.3 部署实践
- **版本备份**：部署前自动备份当前版本
- **配置恢复**：部署后自动恢复 `.env` 配置
- **服务验证**：部署后自动验证服务状态

---

## 总结

本项目实现了一个完整的飞书机器人服务，核心特点：

1. **事件驱动架构**：基于 Flask 的轻量级 Web 服务
2. **多数据源支持**：多维表格、Sheets、其他云文档
3. **数据可视化**：自动生成交互式桑基图
4. **高可用性**：幂等性保证、错误处理、日志记录
5. **安全性**：签名校验、路径防护、配置隔离
6. **易部署**：环境变量配置、一键部署脚本

技术栈选择合理，代码结构清晰，易于维护和扩展。



